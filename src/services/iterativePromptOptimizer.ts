import { llmRouter } from './llmRouter';
import { opikService } from './opikService';

/**
 * Syst√®me d'optimisation it√©rative pour garantir des prompts complets
 * Utilise Opik pour √©valuer et am√©liorer les prompts jusqu'√† ce qu'ils soient complets
 */

export interface CompletenessScore {
  overall: number;
  hasAllSections: boolean;
  allSectionsComplete: boolean;
  noTruncation: boolean;
  properEnding: boolean;
  details: {
    missingSections: string[];
    incompleteSections: string[];
    truncationPoint?: number;
    qualityIssues?: {
      hasOrphanPhrases: boolean;
      hasIncompleteTables: boolean;
      hasIncompleteLists: boolean;
      lacksConcretExample: boolean;
      lacksQuantifiedConstraints: boolean;
    };
  };
}

export interface IterativeOptimizationResult {
  finalPrompt: string;
  iterations: number;
  completenessScore: CompletenessScore;
  improvements: string[];
  traceId: string;
}

class IterativePromptOptimizer {
  private readonly MAX_ITERATIONS = 3;
  private readonly COMPLETENESS_THRESHOLD = 0.9;
  private readonly FREE_MODE_MAX_ITERATIONS = 2; // Mode gratuit: max 2 it√©rations
  private readonly FREE_MODE_THRESHOLD = 0.85; // Mode gratuit: seuil moins strict

  /**
   * Compresse un prompt en mode gratuit en √©liminant tout ce qui n'est pas essentiel
   * tout en maintenant la compl√©tude
   */
  private compressForFreeMode(prompt: string): string {
    console.log('üóúÔ∏è Compression mode gratuit: √©limination des √©l√©ments non essentiels');

    let compressed = prompt;

    // 1. √âLIMINER LES EXEMPLES (trop verbeux pour le mode gratuit)
    compressed = this.removeExamples(compressed);

    // 2. R√âDUIRE LES LISTES √Ä PUCES (garder 3 max par section)
    compressed = this.reduceBulletLists(compressed);

    // 3. SIMPLIFIER LES DESCRIPTIONS (garder l'essentiel)
    compressed = this.simplifyDescriptions(compressed);

    // 4. √âLIMINER LES R√âP√âTITIONS
    compressed = this.removeRedundancy(compressed);

    // 5. COMPACTER LE FORMATAGE (r√©duire espaces inutiles)
    compressed = this.compactFormatting(compressed);

    const originalTokens = this.estimateTokens(prompt);
    const compressedTokens = this.estimateTokens(compressed);
    const reduction = Math.round((1 - compressedTokens / originalTokens) * 100);

    console.log(`‚úÖ Compression termin√©e: ${originalTokens} ‚Üí ${compressedTokens} tokens (-${reduction}%)`);

    return compressed;
  }

  /**
   * √âlimine les sections EXEMPLE qui sont trop verbeuses pour le mode gratuit
   */
  private removeExamples(prompt: string): string {
    // Supprimer les sections EXEMPLE compl√®tes
    const patterns = [
      /\*\*(?:EXEMPLE|EXAMPLE)S?\*\*:?\s*[\s\S]*?(?=\*\*[A-Z]|$)/gi,
      /üìù\s*\*\*(?:EXEMPLE DE SORTIE|EXEMPLE)\*\*\s*[\s\S]*?(?=(?:üéØ|üßë‚Äçüíª|üóÇ|üìè|üìù|\*\*[A-Z])|$)/gi,
    ];

    let result = prompt;
    for (const pattern of patterns) {
      result = result.replace(pattern, '');
    }

    return result;
  }

  /**
   * R√©duit les listes √† puces √† 3 √©l√©ments maximum par section
   */
  private reduceBulletLists(prompt: string): string {
    const lines = prompt.split('\n');
    const result: string[] = [];
    let bulletCount = 0;
    let inBulletList = false;
    let lastSectionHeader = '';

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // D√©tecter les en-t√™tes de section
      if (line.match(/^\*\*[A-Z]/i) || line.match(/^[üéØüßë‚ÄçüíªüóÇüìèüìù]/)) {
        bulletCount = 0;
        inBulletList = false;
        lastSectionHeader = line;
        result.push(lines[i]);
        continue;
      }

      // D√©tecter une puce
      if (line.match(/^[-‚Ä¢*]\s/)) {
        inBulletList = true;
        bulletCount++;

        // Garder seulement les 3 premi√®res puces par section
        if (bulletCount <= 3) {
          result.push(lines[i]);
        } else if (bulletCount === 4) {
          // Ajouter une indication qu'il y a plus d'√©l√©ments
          const indent = lines[i].match(/^(\s*)/)?.[0] || '';
          result.push(`${indent}- [Liste compl√®te disponible en mode Basic+]`);
        }
      } else {
        // Ligne non-puce
        if (inBulletList && line.length === 0) {
          // Ligne vide apr√®s liste - garder
          result.push(lines[i]);
        } else if (!inBulletList || line.length > 0) {
          // Autre contenu - garder
          result.push(lines[i]);
          inBulletList = false;
        }
      }
    }

    return result.join('\n');
  }

  /**
   * Simplifie les descriptions en gardant l'essentiel
   */
  private simplifyDescriptions(prompt: string): string {
    let result = prompt;

    // R√©duire les phrases explicatives longues
    // Pattern: identifier les phrases de plus de 100 caract√®res et les raccourcir
    const sections = result.split(/(\*\*[A-Z][^*]+\*\*:?)/i);

    for (let i = 0; i < sections.length; i++) {
      if (i % 2 === 0) continue; // Sauter les en-t√™tes

      const content = sections[i + 1];
      if (!content) continue;

      // Si le contenu est trop long (>200 chars) et n'est pas une liste
      if (content.length > 200 && !content.includes('- ') && !content.includes('‚Ä¢ ')) {
        // Garder seulement les 2 premi√®res phrases
        const sentences = content.match(/[^.!?]+[.!?]+/g) || [];
        if (sentences.length > 2) {
          sections[i + 1] = sentences.slice(0, 2).join(' ').trim() + '\n';
        }
      }
    }

    return sections.join('');
  }

  /**
   * √âlimine les r√©p√©titions et redondances
   */
  private removeRedundancy(prompt: string): string {
    let result = prompt;

    // √âliminer les phrases qui se r√©p√®tent
    const sentences = result.split(/([.!?]+)/);
    const seen = new Set<string>();
    const filtered: string[] = [];

    for (let i = 0; i < sentences.length; i += 2) {
      const sentence = sentences[i].trim().toLowerCase();
      const punct = sentences[i + 1] || '';

      if (!seen.has(sentence) && sentence.length > 10) {
        filtered.push(sentences[i] + punct);
        seen.add(sentence);
      } else if (sentence.length <= 10) {
        filtered.push(sentences[i] + punct);
      }
    }

    return filtered.join('');
  }

  /**
   * Compacte le formatage en r√©duisant les espaces inutiles
   */
  private compactFormatting(prompt: string): string {
    let result = prompt;

    // R√©duire les sauts de ligne multiples √† 2 maximum
    result = result.replace(/\n{3,}/g, '\n\n');

    // Supprimer les espaces en d√©but/fin de lignes
    result = result.split('\n').map(line => line.trimEnd()).join('\n');

    // Supprimer les lignes vides en d√©but et fin
    result = result.trim();

    return result;
  }

  /**
   * Optimise un prompt de mani√®re it√©rative jusqu'√† ce qu'il soit complet
   */
  async optimizeUntilComplete(
    systemPrompt: string,
    userPrompt: string,
    userId: string,
    maxTokens: number,
    mode: 'free' | 'basic' | 'premium'
  ): Promise<IterativeOptimizationResult> {
    console.log('üîÑ D√©marrage optimisation it√©rative Opik');
    console.log(`üìä Mode: ${mode}, Max tokens: ${maxTokens}`);

    // Adapter les limites selon le mode
    const maxIterations = mode === 'free' ? this.FREE_MODE_MAX_ITERATIONS : this.MAX_ITERATIONS;
    const completenessThreshold = mode === 'free' ? this.FREE_MODE_THRESHOLD : this.COMPLETENESS_THRESHOLD;

    console.log(`üéØ Limites pour mode ${mode}: max ${maxIterations} it√©rations, seuil ${Math.round(completenessThreshold * 100)}%`);

    const traceId = opikService.generateTraceId();
    const improvements: string[] = [];
    let currentPrompt = '';
    let iteration = 0;
    let completenessScore: CompletenessScore;

    // Premi√®re g√©n√©ration
    iteration++;
    console.log(`\nüîÑ It√©ration ${iteration}/${maxIterations}`);

    const firstResponse = await llmRouter.generatePrompt(
      systemPrompt,
      userPrompt,
      maxTokens,
      {
        userId,
        mode,
        traceId
      }
    );

    currentPrompt = firstResponse.content;

    // MODE GRATUIT: Appliquer la compression intelligente apr√®s g√©n√©ration
    if (mode === 'free') {
      console.log('üóúÔ∏è Application compression mode gratuit...');
      const beforeCompression = currentPrompt;
      currentPrompt = this.compressForFreeMode(currentPrompt);

      // Logger la diff√©rence
      improvements.push(`üóúÔ∏è Compression appliqu√©e: ${this.estimateTokens(beforeCompression)} ‚Üí ${this.estimateTokens(currentPrompt)} tokens`);
    }

    completenessScore = this.evaluateCompleteness(currentPrompt, mode);

    console.log('üìä Score de compl√©tude initial:', completenessScore.overall);

    // Logger dans Opik
    await opikService.createTrace({
      userId,
      traceId,
      promptInput: userPrompt,
      promptOutput: currentPrompt,
      model: firstResponse.model,
      latencyMs: 0,
      tokensUsed: firstResponse.usage.total_tokens,
      feedbackScore: completenessScore.overall * 5,
      tags: {
        mode,
        iteration,
        completenessScore: completenessScore.overall,
        maxIterations,
        threshold: completenessThreshold
      }
    });

    // Si le prompt est d√©j√† complet, retourner
    if (completenessScore.overall >= completenessThreshold) {
      console.log('‚úÖ Prompt complet d√®s la premi√®re g√©n√©ration');
      improvements.push(`‚úì Prompt g√©n√©r√© complet d√®s la premi√®re it√©ration (score: ${Math.round(completenessScore.overall * 100)}%)`);

      return {
        finalPrompt: currentPrompt,
        iterations: iteration,
        completenessScore,
        improvements,
        traceId
      };
    }

    // It√©rations d'am√©lioration
    while (iteration < maxIterations && completenessScore.overall < completenessThreshold) {
      iteration++;
      console.log(`\nüîÑ It√©ration ${iteration}/${maxIterations}`);
      console.log('üîç Probl√®mes d√©tect√©s:', completenessScore.details);

      // Cr√©er un prompt de correction bas√© sur l'analyse
      const correctionPrompt = this.buildCorrectionPrompt(
        currentPrompt,
        completenessScore,
        mode
      );

      improvements.push(`It√©ration ${iteration}: ${this.describeIssues(completenessScore)}`);

      // G√©n√©rer une version am√©lior√©e
      const improvedResponse = await llmRouter.generatePrompt(
        correctionPrompt.system,
        correctionPrompt.user,
        maxTokens,
        {
          userId,
          mode,
          traceId: `${traceId}_iter${iteration}`
        }
      );

      currentPrompt = improvedResponse.content;

      // MODE GRATUIT: Appliquer la compression apr√®s chaque it√©ration
      if (mode === 'free') {
        console.log('üóúÔ∏è Application compression apr√®s it√©ration...');
        const beforeCompression = currentPrompt;
        currentPrompt = this.compressForFreeMode(currentPrompt);

        const tokensBefore = this.estimateTokens(beforeCompression);
        const tokensAfter = this.estimateTokens(currentPrompt);
        console.log(`   Compression iter ${iteration}: ${tokensBefore} ‚Üí ${tokensAfter} tokens`);
      }

      completenessScore = this.evaluateCompleteness(currentPrompt, mode);

      console.log(`üìä Score de compl√©tude apr√®s it√©ration ${iteration}:`, completenessScore.overall);

      // Logger l'it√©ration dans Opik
      await opikService.createTrace({
        userId,
        traceId: `${traceId}_iter${iteration}`,
        promptInput: correctionPrompt.user,
        promptOutput: currentPrompt,
        model: improvedResponse.model,
        latencyMs: 0,
        tokensUsed: improvedResponse.usage.total_tokens,
        feedbackScore: completenessScore.overall * 5,
        tags: {
          mode,
          iteration,
          completenessScore: completenessScore.overall,
          parentTraceId: traceId
        }
      });

      // Si le score s'am√©liore peu, arr√™ter
      if (iteration > 1 && completenessScore.overall >= completenessThreshold) {
        console.log('‚úÖ Prompt suffisamment complet');
        break;
      }
    }

    // R√©sum√© des am√©liorations
    improvements.push(`‚úì Score final: ${Math.round(completenessScore.overall * 100)}% apr√®s ${iteration} it√©ration(s)`);

    if (completenessScore.overall >= completenessThreshold) {
      improvements.push('‚úì Prompt enti√®rement complet avec toutes les sections termin√©es');
    } else {
      improvements.push(`‚ö†Ô∏è Prompt am√©lior√© mais limite d'it√©rations atteinte (${maxIterations} max en mode ${mode})`);
    }

    console.log('\n‚úÖ Optimisation it√©rative termin√©e');
    console.log(`üìä Score final: ${Math.round(completenessScore.overall * 100)}%`);
    console.log(`üîÑ It√©rations utilis√©es: ${iteration}`);

    return {
      finalPrompt: currentPrompt,
      iterations: iteration,
      completenessScore,
      improvements,
      traceId
    };
  }

  /**
   * √âvalue la compl√©tude d'un prompt selon la CHECKLIST PRE-PUBLICATION
   */
  private evaluateCompleteness(prompt: string, mode: 'free' | 'basic' | 'premium'): CompletenessScore {
    // Si le prompt contient "---", on √©value uniquement la partie avant le s√©parateur
    // (car apr√®s c'est la section AM√âLIORATIONS qui n'est pas le prompt lui-m√™me)
    let promptToEvaluate = prompt;
    if (prompt.includes('---')) {
      const parts = prompt.split('---');
      promptToEvaluate = parts[0].trim();
      console.log('üìä √âvaluation de la partie avant "---" uniquement');
    }

    const sections = this.detectSections(promptToEvaluate);
    const requiredSections = this.getRequiredSections(mode);

    console.log('üîç Sections d√©tect√©es:', Object.keys(sections).filter(k => sections[k].present));
    console.log('üéØ Sections requises:', requiredSections);

    // CHECKLIST 1: STRUCTURE (sections de base)
    const missingSections = requiredSections.filter(
      section => !sections[section] || !sections[section].present
    );

    const incompleteSections = requiredSections.filter(
      section => sections[section]?.present && !sections[section]?.complete
    );

    // CHECKLIST 2: COMPL√âTUDE (troncation et qualit√© de fin)
    const truncationCheck = this.checkForTruncation(promptToEvaluate);
    const properEnding = this.checkProperEnding(promptToEvaluate);
    const hasOrphanPhrases = this.detectOrphanPhrases(promptToEvaluate);
    const hasIncompleteTables = this.detectIncompleteTables(promptToEvaluate);
    const hasIncompleteLists = this.detectIncompleteBulletLists(promptToEvaluate);

    // CHECKLIST 3: CONTENU (exemple concret, contraintes chiffr√©es)
    const hasConcreteExample = this.hasSubstantialExample(sections['EXEMPLE']);
    const hasQuantifiedConstraints = this.hasQuantifiedConstraints(sections['CONTRAINTES']);

    console.log('‚ùå Sections manquantes:', missingSections);
    console.log('‚ö†Ô∏è Sections incompl√®tes:', incompleteSections);
    console.log('üìã Checklist compl√©tude:', {
      hasOrphanPhrases,
      hasIncompleteTables,
      hasIncompleteLists,
      hasConcreteExample,
      hasQuantifiedConstraints
    });

    // Calculer le score global selon la CHECKLIST
    const hasAllSections = missingSections.length === 0;
    const allSectionsComplete = incompleteSections.length === 0;
    const noTruncation = !truncationCheck.truncated;
    const noOrphans = !hasOrphanPhrases;
    const noIncompleteTables = !hasIncompleteTables;
    const noIncompleteLists = !hasIncompleteLists;

    let score = 0;

    // 30% pour avoir toutes les sections requises
    if (hasAllSections) score += 0.30;
    else score += (1 - missingSections.length / requiredSections.length) * 0.30;

    // 30% pour que toutes les sections soient compl√®tes
    if (allSectionsComplete) score += 0.30;
    else score += (1 - incompleteSections.length / requiredSections.length) * 0.30;

    // 15% pour l'absence de troncation et fin propre
    if (noTruncation && properEnding) score += 0.15;
    else if (noTruncation || properEnding) score += 0.075;

    // 10% pour l'absence d'√©l√©ments orphelins/incomplets
    if (noOrphans && noIncompleteTables && noIncompleteLists) score += 0.10;
    else {
      let subScore = 0;
      if (noOrphans) subScore += 0.033;
      if (noIncompleteTables) subScore += 0.033;
      if (noIncompleteLists) subScore += 0.033;
      score += subScore;
    }

    // 15% pour la qualit√© du contenu (exemple + contraintes)
    if (hasConcreteExample && hasQuantifiedConstraints) score += 0.15;
    else {
      if (hasConcreteExample) score += 0.10;
      if (hasQuantifiedConstraints) score += 0.05;
    }

    console.log('üìä Score de compl√©tude calcul√©:', Math.round(score * 100) + '%');

    return {
      overall: Math.round(score * 100) / 100,
      hasAllSections,
      allSectionsComplete,
      noTruncation,
      properEnding,
      details: {
        missingSections,
        incompleteSections,
        truncationPoint: truncationCheck.truncated ? truncationCheck.position : undefined,
        qualityIssues: {
          hasOrphanPhrases,
          hasIncompleteTables,
          hasIncompleteLists,
          lacksConcretExample: !hasConcreteExample,
          lacksQuantifiedConstraints: !hasQuantifiedConstraints
        }
      }
    };
  }

  /**
   * D√©tecte les sections pr√©sentes dans le prompt et leur compl√©tude
   */
  private detectSections(prompt: string): Record<string, { present: boolean; complete: boolean; content: string }> {
    const sections: Record<string, { present: boolean; complete: boolean; content: string }> = {};

    // Patterns pour format standard (avec ou sans √©mojis)
    const sectionPatterns = {
      'R√îLE': [
        /\*\*(?:R√îLE|ROLE)\*\*:?\s*([\s\S]*?)(?=(?:üéØ|üßë‚Äçüíª|üóÇ|üìè|üìù|\*\*[A-Z]|---|\n\n\n)|$)/i,
        /üßë‚Äçüíª\s*\*\*(?:R√îLE DE L'IA|R√îLE)\*\*\s*([\s\S]*?)(?=(?:üéØ|üßë‚Äçüíª|üóÇ|üìè|üìù|\*\*[A-Z]|---|\n\n\n)|$)/i
      ],
      'CONTEXTE': [
        /\*\*(?:CONTEXTE|CONTEXT)\*\*:?\s*([\s\S]*?)(?=(?:üéØ|üßë‚Äçüíª|üóÇ|üìè|üìù|\*\*[A-Z]|---|\n\n\n)|$)/i,
        /üéØ\s*\*\*(?:CONTEXTE & OBJECTIF|CONTEXTE)\*\*\s*([\s\S]*?)(?=(?:üéØ|üßë‚Äçüíª|üóÇ|üìè|üìù|\*\*[A-Z]|---|\n\n\n)|$)/i
      ],
      'OBJECTIF': [
        /\*\*(?:OBJECTIF|OBJECTIVE|MISSION)\*\*:?\s*([\s\S]*?)(?=(?:üéØ|üßë‚Äçüíª|üóÇ|üìè|üìù|\*\*[A-Z]|---|\n\n\n)|$)/i,
        /üéØ\s*\*\*(?:CONTEXTE & OBJECTIF|OBJECTIF)\*\*\s*([\s\S]*?)(?=(?:üéØ|üßë‚Äçüíª|üóÇ|üìè|üìù|\*\*[A-Z]|---|\n\n\n)|$)/i
      ],
      'INSTRUCTIONS': [
        /\*\*(?:INSTRUCTIONS|T√ÇCHES|TASKS)\*\*:?\s*([\s\S]*?)(?=(?:üéØ|üßë‚Äçüíª|üóÇ|üìè|üìù|\*\*[A-Z]|---|\n\n\n)|$)/i
      ],
      'FORMAT': [
        /\*\*(?:FORMAT|LIVRABLE|OUTPUT)\*\*:?\s*([\s\S]*?)(?=(?:üéØ|üßë‚Äçüíª|üóÇ|üìè|üìù|\*\*[A-Z]|---|\n\n\n)|$)/i,
        /üóÇ\s*\*\*(?:STRUCTURE DU LIVRABLE|FORMAT)\*\*\s*([\s\S]*?)(?=(?:üéØ|üßë‚Äçüíª|üóÇ|üìè|üìù|\*\*[A-Z]|---|\n\n\n)|$)/i
      ],
      'CONTRAINTES': [
        /\*\*(?:CONTRAINTES|CONSTRAINTS|R√àGLES)\*\*:?\s*([\s\S]*?)(?=(?:üéØ|üßë‚Äçüíª|üóÇ|üìè|üìù|\*\*[A-Z]|---|\n\n\n)|$)/i,
        /üìè\s*\*\*(?:CONTRAINTES)\*\*\s*([\s\S]*?)(?=(?:üéØ|üßë‚Äçüíª|üóÇ|üìè|üìù|\*\*[A-Z]|---|\n\n\n)|$)/i
      ],
      'EXEMPLE': [
        /\*\*(?:EXEMPLE|EXAMPLE)\*\*:?\s*([\s\S]*?)(?=(?:\*\*[A-Z]|---|\n\n\n)|$)/i,
        /üìù\s*\*\*(?:EXEMPLE DE SORTIE|EXEMPLE)\*\*\s*([\s\S]*?)(?=(?:\*\*[A-Z]|---|\n\n\n)|$)/i
      ],
    };

    for (const [sectionName, patterns] of Object.entries(sectionPatterns)) {
      let found = false;

      // Essayer chaque pattern pour cette section
      for (const pattern of patterns) {
        const match = prompt.match(pattern);
        if (match && match[1]) {
          const content = match[1].trim();
          sections[sectionName] = {
            present: true,
            complete: this.isSectionComplete(content, sectionName),
            content
          };
          found = true;
          break;
        }
      }

      if (!found) {
        sections[sectionName] = {
          present: false,
          complete: false,
          content: ''
        };
      }
    }

    return sections;
  }

  /**
   * V√©rifie si une section est compl√®te
   */
  private isSectionComplete(content: string, sectionName?: string): boolean {
    if (!content || content.length < 10) return false;

    // R√àGLE SP√âCIALE pour la section EXEMPLE: elle doit √™tre plus substantielle
    if (sectionName === 'EXEMPLE') {
      // Un exemple doit avoir au moins 50 caract√®res et 2 lignes
      const lines = content.trim().split('\n').filter(l => l.trim().length > 0);
      if (lines.length < 2 || content.length < 50) {
        console.log(`‚ö†Ô∏è Section EXEMPLE incompl√®te: ${lines.length} lignes, ${content.length} caract√®res`);
        return false;
      }
    }

    // V√©rifier que la section ne se termine pas brusquement
    const lastLine = content.trim().split('\n').pop() || '';
    const lastChar = content.trim().slice(-1);

    // Si √ßa se termine par une ponctuation appropri√©e ou un point de liste
    if (lastChar.match(/[.!?:]/) || lastLine.match(/^[-‚Ä¢]\s/)) {
      return true;
    }

    // Si c'est une liste, v√©rifier qu'au moins un √©l√©ment est complet
    if (content.includes('-') || content.includes('‚Ä¢')) {
      const listItems = content.split('\n').filter(line => line.trim().match(/^[-‚Ä¢]\s/));
      return listItems.length > 0 && listItems.some(item => item.trim().match(/[.!?]$/));
    }

    return false;
  }

  /**
   * V√©rifie si le prompt est tronqu√©
   */
  private checkForTruncation(prompt: string): { truncated: boolean; position?: number } {
    const lines = prompt.split('\n');
    const lastLine = lines[lines.length - 1].trim();
    const lastChar = prompt.trim().slice(-1);

    // Exception: Si le prompt se termine par "---" suivi d'une section AM√âLIORATIONS
    // ce n'est PAS une troncation mais un s√©parateur intentionnel
    if (prompt.includes('---') && prompt.includes('AM√âLIORATIONS APPORT√âES')) {
      // V√©rifier si le texte apr√®s --- est complet
      const afterSeparator = prompt.split('---')[1];
      if (afterSeparator && afterSeparator.trim().length > 20) {
        // Il y a du contenu apr√®s ---, donc pas de troncation
        return { truncated: false };
      }
    }

    // Signes de troncation
    const truncationPatterns = [
      /\.\.\.$/,        // Se termine par ...
      /[,;]\s*$/,       // Se termine par une virgule ou point-virgule
      /\([^)]*$/,       // Parenth√®se ouvrante non ferm√©e
      /\[[^\]]*$/,      // Crochet ouvrant non ferm√©
      /^[-‚Ä¢]\s+\w+\s*$/, // Liste √† puce sans ponctuation
    ];

    for (const pattern of truncationPatterns) {
      if (pattern.test(lastLine) || pattern.test(prompt.slice(-50))) {
        return { truncated: true, position: prompt.length - 50 };
      }
    }

    // Si la derni√®re ligne est tr√®s courte et sans ponctuation (sauf si c'est juste apr√®s ---)
    if (lastLine.length < 20 && !lastChar.match(/[.!?:]/) && !prompt.trim().endsWith('---')) {
      return { truncated: true, position: prompt.length - lastLine.length };
    }

    return { truncated: false };
  }

  /**
   * V√©rifie que le prompt se termine proprement
   */
  private checkProperEnding(prompt: string): boolean {
    const lastLine = prompt.trim().split('\n').pop() || '';
    const lastChar = prompt.trim().slice(-1);

    // Fin acceptable
    return lastChar.match(/[.!?]/) !== null || lastLine.match(/^[-‚Ä¢]\s.*[.!?]$/) !== null;
  }

  /**
   * Retourne les sections requises selon le mode
   * Note: Pour la section am√©lioration, CONTEXTE et OBJECTIF peuvent √™tre fusionn√©s
   */
  private getRequiredSections(mode: 'free' | 'basic' | 'premium'): string[] {
    if (mode === 'premium') {
      // CONTEXTE et OBJECTIF sont essentiels (m√™me s'ils peuvent √™tre fusionn√©s dans le format am√©lioration)
      // EXEMPLE est critique car souvent tronqu√©
      return ['R√îLE', 'CONTEXTE', 'FORMAT', 'CONTRAINTES', 'EXEMPLE'];
    } else if (mode === 'basic') {
      return ['R√îLE', 'CONTEXTE', 'FORMAT', 'CONTRAINTES'];
    } else {
      // MODE GRATUIT: Sections minimales essentielles (pas d'EXEMPLE car supprim√© par compression)
      return ['R√îLE', 'OBJECTIF', 'INSTRUCTIONS'];
    }
  }

  /**
   * CHECKLIST: D√©tecte les phrases orphelines (ex: "Code snippets :" seul)
   */
  private detectOrphanPhrases(prompt: string): boolean {
    const lines = prompt.split('\n').map(l => l.trim()).filter(l => l.length > 0);

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      // Une phrase orpheline se termine par ":" sans contenu apr√®s
      if (line.endsWith(':') && line.length < 50) {
        // V√©rifier si la ligne suivante existe et contient du contenu
        const nextLine = i < lines.length - 1 ? lines[i + 1] : '';

        // Si c'est la derni√®re ligne ou si la suivante est vide/courte, c'est orphelin
        if (!nextLine || nextLine.length < 10) {
          console.log('üö® Phrase orpheline d√©tect√©e:', line);
          return true;
        }
      }
    }

    return false;
  }

  /**
   * CHECKLIST: D√©tecte les tableaux incomplets (header sans ligne d'exemple)
   */
  private detectIncompleteTables(prompt: string): boolean {
    const lines = prompt.split('\n');

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // D√©tecte un header de tableau markdown (avec |)
      if (line.includes('|') && line.split('|').length > 2) {
        // V√©rifier s'il y a une ligne de s√©paration apr√®s (|---|---|)
        const nextLine = i < lines.length - 1 ? lines[i + 1].trim() : '';
        const hasSeperator = nextLine.includes('---') && nextLine.includes('|');

        if (hasSeperator) {
          // V√©rifier s'il y a au moins une ligne de donn√©es apr√®s le s√©parateur
          const dataLine = i < lines.length - 2 ? lines[i + 2].trim() : '';

          if (!dataLine || !dataLine.includes('|')) {
            console.log('üö® Tableau incomplet d√©tect√© (header sans donn√©es)');
            return true;
          }
        }
      }
    }

    return false;
  }

  /**
   * CHECKLIST: D√©tecte les listes √† puces incompl√®tes
   */
  private detectIncompleteBulletLists(prompt: string): boolean {
    const lines = prompt.split('\n').map(l => l.trim()).filter(l => l.length > 0);

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      // D√©tecte une puce (-, ‚Ä¢, *)
      if (line.match(/^[-‚Ä¢*]\s/)) {
        // V√©rifier si la ligne de puce est trop courte ou sans contenu
        const content = line.replace(/^[-‚Ä¢*]\s/, '').trim();

        if (content.length < 5 || content.endsWith(':')) {
          console.log('üö® Liste √† puce incompl√®te:', line);
          return true;
        }
      }
    }

    return false;
  }

  /**
   * CHECKLIST: V√©rifie si la section EXEMPLE a un contenu substantiel et concret
   */
  private hasSubstantialExample(exempleSection: { present: boolean; complete: boolean; content: string } | undefined): boolean {
    if (!exempleSection || !exempleSection.present || !exempleSection.content) {
      return false;
    }

    const content = exempleSection.content.trim();

    // Un exemple substantiel doit avoir:
    // - Au moins 100 caract√®res (pas juste un titre)
    // - Au moins 3 lignes
    // - Du contenu concret (pas juste des placeholders)

    const lines = content.split('\n').filter(l => l.trim().length > 0);
    const hasMinLength = content.length >= 100;
    const hasMinLines = lines.length >= 3;
    const hasConcreteContent = !content.includes('[√† compl√©ter]') &&
                               !content.includes('[example]') &&
                               !content.includes('[...]');

    const isSubstantial = hasMinLength && hasMinLines && hasConcreteContent;

    if (!isSubstantial) {
      console.log('‚ö†Ô∏è Exemple non substantiel:', { hasMinLength, hasMinLines, hasConcreteContent });
    }

    return isSubstantial;
  }

  /**
   * CHECKLIST: V√©rifie si les contraintes contiennent des chiffres/mesures concr√®tes
   */
  private hasQuantifiedConstraints(contraintesSection: { present: boolean; complete: boolean; content: string } | undefined): boolean {
    if (!contraintesSection || !contraintesSection.present || !contraintesSection.content) {
      return false;
    }

    const content = contraintesSection.content;

    // Cherche des patterns de quantification:
    // - Nombres (100, 200-250, <2, >5)
    // - Unit√©s (mots, caract√®res, secondes, tokens, ko, mo)
    // - Pourcentages (80%, 90%)

    const quantificationPatterns = [
      /\d+\s*-\s*\d+/,           // Range: 200-250
      /[<>‚â§‚â•]\s*\d+/,            // Comparaison: <2, >5
      /\d+\s*(mots?|caract√®res?|secondes?|minutes?|tokens?|ko|mo|go)/i,
      /\d+%/,                     // Pourcentages: 80%
      /\d+\s*lignes?/i,          // Lignes: 10 lignes
    ];

    const hasQuantification = quantificationPatterns.some(pattern => pattern.test(content));

    if (!hasQuantification) {
      console.log('‚ö†Ô∏è Contraintes sans quantification d√©tect√©e');
    }

    return hasQuantification;
  }

  /**
   * Construit un prompt de correction bas√© sur l'analyse
   */
  private buildCorrectionPrompt(
    currentPrompt: string,
    score: CompletenessScore,
    mode: string
  ): { system: string; user: string } {
    const issues: string[] = [];

    // CHECKLIST STRUCTURE
    if (score.details.missingSections.length > 0) {
      issues.push(`Sections manquantes: ${score.details.missingSections.join(', ')}`);
    }

    if (score.details.incompleteSections.length > 0) {
      issues.push(`Sections incompl√®tes: ${score.details.incompleteSections.join(', ')}`);
    }

    // CHECKLIST COMPL√âTUDE
    if (!score.noTruncation) {
      issues.push('Le prompt est tronqu√© et doit √™tre compl√©t√©');
    }

    if (!score.properEnding) {
      issues.push('Le prompt ne se termine pas proprement');
    }

    // CHECKLIST QUALIT√â
    const qualityIssues = score.details.qualityIssues;
    if (qualityIssues) {
      if (qualityIssues.hasOrphanPhrases) {
        issues.push('Phrases orphelines d√©tect√©es (ex: "Code snippets :" sans suite) - √Ä compl√©ter');
      }
      if (qualityIssues.hasIncompleteTables) {
        issues.push('Tableaux incomplets (header sans ligne d\'exemple) - Ajouter au moins 1 ligne');
      }
      if (qualityIssues.hasIncompleteLists) {
        issues.push('Listes √† puces incompl√®tes - Compl√©ter chaque √©l√©ment');
      }
      if (qualityIssues.lacksConcretExample) {
        issues.push('Section EXEMPLE manquante ou non substantielle - Ajouter un exemple concret de 3-5 lignes minimum');
      }
      if (qualityIssues.lacksQuantifiedConstraints) {
        issues.push('Contraintes sans chiffres - Ajouter des mesures concr√®tes (ex: 200-250 mots, <2s, 80%)');
      }
    }

    // D√©tecter si c'est un format avec √©mojis (format am√©lioration)
    const hasEmojiFormat = currentPrompt.includes('üéØ') || currentPrompt.includes('üßë‚Äçüíª') || currentPrompt.includes('üóÇ');

    const systemPrompt = hasEmojiFormat
      ? `Tu es un expert en correction de prompts selon la CHECKLIST PRE-PUBLICATION professionnelle.

üìã CHECKLIST √Ä RESPECTER:

**STRUCTURE** (obligatoire):
‚úì Introduction claire (contexte + objectif)
‚úì R√¥le de l'IA d√©fini pr√©cis√©ment
‚úì Livrables attendus explicit√©s
‚úì Section Contraintes pr√©sente
‚úì Section Exemples pr√©sente

**COMPL√âTUDE** (critique):
‚úì Le prompt ne s'arr√™te PAS brutalement
‚úì Derni√®re section COMPL√àTE (lire jusqu'√† la fin)
‚úì Z√âRO phrases orphelines (ex: "Code snippets :" seul)
‚úì Tableaux commenc√©s = tableaux termin√©s (min 1 ligne de donn√©es)
‚úì Listes compl√®tes (pas de bullet point vide)

**CONTENU** (qualit√©):
‚úì Exemple de sortie CONCRET (min 3-5 lignes, pas de placeholder)
‚úì Contraintes CHIFFR√âES (200-250 mots, <2s, 80%, etc.)
‚úì Ton coh√©rent du d√©but √† la fin

FORMAT SP√âCIFIQUE avec √©mojis:
üéØ **CONTEXTE & OBJECTIF** ‚Üí 2-3 phrases COMPL√àTES
üßë‚Äçüíª **R√îLE DE L'IA** ‚Üí 2 phrases COMPL√àTES
üóÇ **STRUCTURE DU LIVRABLE** ‚Üí Liste ou description COMPL√àTE
üìè **CONTRAINTES** ‚Üí Contraintes CHIFFR√âES (avec nombres/unit√©s)
üìù **EXEMPLE DE SORTIE** ‚Üí Exemple CONCRET de 5+ lignes (pas [√† compl√©ter])

üö® PROBL√àMES D√âTECT√âS √Ä CORRIGER:
${issues.map((issue, i) => `${i + 1}. ${issue}`).join('\n')}

R√àGLE D'OR: Ne retourne le prompt QUE si tu peux cocher TOUS les points de la checklist.`
      : `Tu es un expert en correction de prompts selon la CHECKLIST PRE-PUBLICATION professionnelle.

üìã CHECKLIST √Ä RESPECTER:

**STRUCTURE** (obligatoire):
‚úì Introduction claire (contexte + objectif)
‚úì R√¥le de l'IA d√©fini pr√©cis√©ment
‚úì Livrables attendus explicit√©s
‚úì Section Contraintes pr√©sente
‚úì Section Exemples pr√©sente

**COMPL√âTUDE** (critique):
‚úì Le prompt ne s'arr√™te PAS brutalement
‚úì Derni√®re section COMPL√àTE (lire jusqu'√† la fin)
‚úì Z√âRO phrases orphelines (ex: "Code snippets :" seul)
‚úì Tableaux commenc√©s = tableaux termin√©s (min 1 ligne de donn√©es)
‚úì Listes compl√®tes (pas de bullet point vide)

**CONTENU** (qualit√©):
‚úì Exemple de sortie CONCRET (min 3-5 lignes, pas de placeholder)
‚úì Contraintes CHIFFR√âES (200-250 mots, <2s, 80%, etc.)
‚úì Ton coh√©rent du d√©but √† la fin

üö® PROBL√àMES D√âTECT√âS √Ä CORRIGER:
${issues.map((issue, i) => `${i + 1}. ${issue}`).join('\n')}

R√àGLE D'OR: Ne retourne le prompt QUE si tu peux cocher TOUS les points de la checklist.`;

    // Construire des instructions sp√©cifiques selon les probl√®mes d√©tect√©s
    const specificInstructions: string[] = [];

    if (qualityIssues?.hasIncompleteTables) {
      specificInstructions.push(`
‚ö†Ô∏è TABLEAU INCOMPLET D√âTECT√â:
Si tu vois un tableau avec seulement le header (exemple: | Col1 | Col2 |), tu DOIS ajouter AU MINIMUM 2-3 lignes de donn√©es concr√®tes.

Exemple INCORRECT:
| Temps | Action |
|-------|--------|

Exemple CORRECT:
| Temps | Action |
|-------|--------|
| 0-2s  | Gros plan sur visage |
| 2-5s  | Plan large de la sc√®ne |
| 5-10s | Zoom sur l'objet cl√© |`);
    }

    if (hasEmojiFormat && qualityIssues?.lacksConcretExample) {
      specificInstructions.push(`
‚ö†Ô∏è EXEMPLE MANQUANT/INCOMPLET:
La section üìù **EXEMPLE DE SORTIE** doit contenir un exemple R√âEL et CONCRET (minimum 5 lignes).
Ne mets PAS de placeholder comme [√† compl√©ter] ou [example].
G√©n√®re un exemple complet qui montre exactement √† quoi doit ressembler le r√©sultat final.`);
    }

    if (qualityIssues?.lacksQuantifiedConstraints) {
      specificInstructions.push(`
‚ö†Ô∏è CONTRAINTES SANS CHIFFRES:
Toutes les contraintes doivent √™tre QUANTIFI√âES avec des nombres pr√©cis.
Exemple: Remplace "Longueur: Courte" par "Longueur: 200-250 mots"
         Remplace "Rapide" par "< 2 secondes"
         Remplace "La plupart" par "80% minimum"`);
    }

    const userPrompt = `Voici le prompt incomplet √† corriger:

${currentPrompt}

${specificInstructions.length > 0 ? specificInstructions.join('\n') : ''}

üéØ MISSION: CORRIGE ET COMPL√àTE ce prompt en r√©solvant TOUS les probl√®mes identifi√©s ci-dessus.

R√àGLES STRICTES:
- Si un tableau a seulement un header, AJOUTE au moins 2-3 lignes de donn√©es
- Si une phrase se termine par ":", AJOUTE le contenu qui suit
- Si une section "EXEMPLE" est vide, G√âN√àRE un exemple concret de 5+ lignes
- Si des contraintes manquent de chiffres, AJOUTE des valeurs num√©riques pr√©cises

Retourne UNIQUEMENT le prompt corrig√© COMPLET, sans commentaire ni explication.`;

    return { system: systemPrompt, user: userPrompt };
  }

  /**
   * D√©crit les probl√®mes identifi√©s
   */
  private describeIssues(score: CompletenessScore): string {
    const issues: string[] = [];

    if (score.details.missingSections.length > 0) {
      issues.push(`ajout sections: ${score.details.missingSections.join(', ')}`);
    }

    if (score.details.incompleteSections.length > 0) {
      issues.push(`compl√©tion sections: ${score.details.incompleteSections.join(', ')}`);
    }

    if (!score.noTruncation) {
      issues.push('correction troncation');
    }

    if (!score.properEnding) {
      issues.push('am√©lioration fin de prompt');
    }

    return issues.join('; ');
  }
}

export const iterativePromptOptimizer = new IterativePromptOptimizer();
